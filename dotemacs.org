#+TITLE: Emacs configuration
#+STARTUP: content

This is my Emacs configuration.  It is pretty much like any other,
with maybe a few interesting properties:

 + It uses a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style with Org-Mode.  Although the
   documentation is admittedly scarce, it makes the configuration easy
   to organize and understand.

 + It uses the excellent [[https://github.com/emacscollective/borg][Borg]] package manager instead of anything
   based on =package.el=, including =use-package=.  Borg has a lot of
   interesting properties compared to the alternatives: since packages
   (‚Äúdrones‚Äù) are Git submodules, they can be modified and contributed
   back.  Submodules also guarantee excellent configuration
   reproducibility, since you manually configure which version of
   which package you want installed, and version here means a /commit/
   --- you don't get finer-grained than that.

 + It has a whole section dedicated to [[#writing-prose][writing prose]].

 + It uses [[https://github.com/abo-abo/swiper][Ivy]] /and/ (a bit of) [[https://github.com/emacs-helm/helm][Helm]].  The bulk of completion is
   performed through Ivy, but in some rare cases where Helm is still
   required, or is a better fit for the job, Helm is used instead.

* Contents :TOC_1:noexport:
- [[#introduction][Introduction]]
- [[#user-interface][User interface]]
- [[#divine-modal-editing][DivINE: Modal editing]]
- [[#editing-text][Editing text]]
- [[#writing-prose][Writing prose]]
- [[#writing-code][Writing code]]
- [[#tools][Tools]]
- [[#conclusion][Conclusion]]

* Introduction

This chapter deals with the general use of Emacs, and is limited to
general settings and sane defaults.  It's a bit messy, since it's
mostly made up of all the bits that don't fit anywhere else.

Let's start by saying hello.  Beyond being polite, when starting
daemon it helps identifying when the literate configuration has
started running.

#+begin_src emacs-lisp :tangle yes
  (message "
  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó
  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë
  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë
  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïù
  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïó
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù
  ")
#+END_SRC

And introduce ourselves:

#+begin_src emacs-lisp :tangle yes
  (setq user-full-name    "Thibault Polge"
        user-mail-address "thibault@thb.lt")
#+end_src

Before we do anything serious, we run =no-littering= to prevent packages
putting their configuration in random places:

#+begin_src emacs-lisp :tangle yes
  (want-drone no-littering)
  (require 'no-littering)
#+end_src

For some reason, the default value of =max-specpdl-size= prevents [[Mu4e][Mu4e]]
from correctly rendering some HTML e-mails.  We increase it from 1300
to 5000.

#+begin_src emacs-lisp :tangle yes
  (setq max-specpdl-size 5000)
#+END_SRC

Change the default major mode to =text-mode= instead of
=fundamental-mode=.  Fundamental has no hooks.

#+begin_src emacs-lisp :tangle yes
  (setq-default major-mode 'text-mode)
#+end_src

We want numbered backups, because catastrophes happen.  The numbers
may be a bit crazy, but better safe than sorry.

#+begin_src emacs-lisp :tangle yes
  (setq version-control t
        kept-new-versions 500
        kept-old-versions 500)
#+END_SRC

Disable Customize by pointing it to =/dev/null=:

#+begin_src emacs-lisp :tangle yes
  (setq custom-file "/dev/null")
  (load custom-file t)
#+END_SRC

Use default browser from the system. Using =setsid xdg-open= prevents
Emacs from killing xdg-open before it actually opened anything. See
[[https://askubuntu.com/questions/646631/emacs-doesnot-work-with-xdg-open][here]].

#+begin_src emacs-lisp :tangle yes
  (setq-default
   browse-url-browser-function 'browse-url-generic
   browse-url-generic-program "setsid"
   browse-url-generic-args '("xdg-open"))
#+end_src

Don't lose the contents of system clipboard when killing from Emacs:

#+begin_src emacs-lisp :tangle yes
  (setq save-interprogram-paste-before-kill t)
#+end_src

Running Emacs under MacOS requires a few adjustements:

#+begin_src emacs-lisp :tangle yes
  (want-drone exec-path-from-shell)

  (when (string= system-type 'darwin)
    ;; Don't use alt, cmd is meta
    (setq mac-option-modifier 'nil
          mac-command-modifier 'meta)

    ; Fix weird Apple keymap.on full-size kbs.
    (global-set-key (kbd "<help>") 'overwrite-mode)

    ; Fix load-path for mu4e (not sure this is still needed)
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")

    ; Load path from a shell
    (exec-path-from-shell-initialize))
#+end_src

* User interface

#+begin_src emacs-lisp :tangle yes
  (want-drones diminish
               general
               hydra
               visual-fill-column)
#+end_src

** Settings and general configuration

#+begin_src emacs-lisp :tangle yes
  (setq-default
   cursor-type '(bar . 5)
   enable-recursive-minibuffers t
   inhibit-startup-screen t
   use-dialog-box nil
   vc-follow-symlinks t

   truncate-lines t

   disabled-command-function nil)
#+end_src

Never use the "safe" ~yes-or-no~ function:

#+begin_src emacs-lisp :tangle yes
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

Don't show the menu bar, unless this is MacOS.  Never show toolbar or
scrollbars.

#+begin_src emacs-lisp :tangle yes
  (unless (string= 'system-type 'darwin) (menu-bar-mode -1))
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

Mouse wheel scrolling makes big jumps by default, let's make it smoother.

#+begin_src emacs-lisp :tangle yes
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)) ;; one line at a time
        mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
        mouse-wheel-follow-mouse 't ;; scroll window under mouse

        scroll-step 1 ;; keyboard scroll one line at a time
        )
#+end_src

Rebind =C-x k= to kill the /current/ buffer.

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C-x k") (lambda () (interactive) (kill-buffer (current-buffer))))
#+end_src

** Fonts and themes

Configure the default font:

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono"))
  (set-face-attribute 'default nil
                      :height 70)
#+end_src

And load the default theme: [[https://github.com/thblt/eziam-theme-emacs][Eziam]].

#+begin_src emacs-lisp :tangle yes
  (want-drone eziam-theme-emacs)

  (setq eziam-scale-headings nil)
  (load-theme 'eziam-dark t)
#+end_src

By default, multiple themes can be loaded at the same time.  Nobody
wants this (although it's required by =smart-mode-line=)

#+begin_src emacs-lisp :tangle yes
  (defadvice load-theme (before theme-dont-propagate activate)
    (mapc #'disable-theme custom-enabled-themes))
#+end_src

Create some shortcut commands to load both Eziam themes:

#+begin_src emacs-lisp :tangle yes
  (defun eziam-dark () (interactive) (load-theme 'eziam-dark t))
  (defun eziam-light () (interactive) (load-theme 'eziam-light t))
  (defun eziam-dusk () (interactive) (load-theme 'eziam-dusk t))
#+END_SRC

** Mode line

*** The mode line itself

#+begin_src emacs-lisp :tangle yes
  (want-drone kurecolor)

  (require 'kurecolor)
#+END_SRC

#+begin_src emacs-lisp :tangle yes
  (setq x-underline-at-descent-line t)

  (defun thblt/mode-line-set-faces (&rest args)
    (let* ((default-bg (face-attribute 'default :background))
     (default-fg (face-attribute 'default :foreground))

     ;; @FIXME This is NOT a good way to compute brightnesqs.  Average the three components.
     (dark (< (kurecolor-hex-get-brightness default-bg) .5))
     (brightness-step (if dark .05 -.05))
     ;; active
     (ac-bg (kurecolor-adjust-brightness default-bg (* 12 brightness-step)))
     (ac-fg (if dark "black" "white"))
     ;; inactive
     (in-bg (kurecolor-adjust-brightness default-bg (* 2 brightness-step)))
     (in-fg (kurecolor-adjust-brightness default-bg (* (if dark 5 1) brightness-step))))

      (face-spec-set 'mode-line
                     `((t
                        :background ,ac-bg
                        :foreground ,ac-fg
                        :underline ,ac-bg
                        :overline ,ac-bg)))

      (face-spec-set 'mode-line-inactive
                     `((t
                        :background ,in-bg
                        :foreground ,in-fg
                        :underline ,in-bg
                        :overline ,in-fg)))

      (face-spec-set 'thblt/mode-line-server-name-face
                     `((t
                        :foreground "white"
                        :background ,(kurecolor-hsv-to-hex
                                     .85
                                     .95
                                     (kurecolor-hex-get-brightness ac-bg))
                        :box ,default-fg)))

      (face-spec-set 'thblt/mode-line-inactive-invisible
                     `((t
                        :foreground ,default-bg
                        :background ,default-bg
                        :underline ,default-bg
                        :overline ,default-bg)))))

  (thblt/mode-line-set-faces)
  (advice-add 'load-theme :after 'thblt/mode-line-set-faces)

  (defun thblt/mode-line-get-face (base &optional variant)
    "Select a face for the mode-line."
    (intern (format "thblt/mode-line-%s%s%s-face"
        base
        (if active "-active" "")
        (if variant (concat "-" variant) ""))))

  (defun thblt/mode-line-wrap (str)
    (if str (concat " " str " ") ""))

  (defun thblt/mode-line-sep (str)
    (if str (concat str " ") ""))

  (setq-default
   mode-line-format
   '((:eval
      (when (and (bound-and-true-p eyebrowse-mode) ;; Eyebrowse is bound and on
                 (window-parameter (selected-window) 'thblt/window-at-bottom-left)) ;;
        (let* ((num (eyebrowse--get 'current-slot))
               (tag (when num (nth 2 (assoc num (eyebrowse--get 'window-configs)))))
               (str (if (and tag (< 0 (length tag)))
                        tag
                      (when num (int-to-string num)))))
          (propertize (thblt/mode-line-wrap str) 'face '(:weight bold :background "#FFCC33" :foreground "black" :box t)))))

     " "

     (:eval
       (propertize
       (thblt/mode-line-sep (concat
         (and buffer-read-only "ÓÇ¢")
         (and (buffer-file-name) (buffer-modified-p) "üíæ")))
       'face '(:foreground "red")))

     (:eval (propertized-buffer-identification "%12b"))

     "  %3l:%2c "

     "  ["
     (:eval (propertize mode-name 'face 'bold))
     minor-mode-alist
     "]   "


     (:eval
      (when (or (projectile-project-p)
                vc-mode)
         (concat
          (when (projectile-project-p) (format "%s " (projectile-project-name)))
          (--when-let vc-mode (format "ÓÇ† %s" (substring it 1))))))

     (:eval (when (or (projectile-project-p)
                vc-mode) "   ")) ;; Not the cleanest way to add a conditional separator...

     (:eval (thblt/mode-line-sep
             (when (and (and (boundp 'server-process) server-process)
                        (window-parameter (selected-window) 'thblt/window-at-bottom-right))

               (propertize (thblt/mode-line-wrap server-name) 'face 'thblt/mode-line-server-name-face))))))
#+END_SRC

*** The window position tracker

#+begin_src emacs-lisp :tangle yes
  (defun thblt/window-at-bottom-left-p (win)
    "Return non-nil if WIN is at the bottom left of the frame."
    (not (or
          (window-in-direction 'below win)
          (window-in-direction 'left win))))

  (defun thblt/window-at-bottom-right-p (win)
    "Return non-nil if WIN is at the bottom right of the frame."
    (not (or
          (window-in-direction 'below win)
          (window-in-direction 'right win))))

  (defun thblt/update-window-position-parameters ()
    (mapc (lambda (win)
            (set-window-parameter win 'thblt/window-at-bottom-left (thblt/window-at-bottom-left-p win))
            (set-window-parameter win 'thblt/window-at-bottom-right (thblt/window-at-bottom-right-p win)))
          (window-list (selected-frame) nil)))

  (add-hook 'window-configuration-change-hook 'thblt/update-window-position-parameters)



#+END_SRC

** TODO Project management with Projectile

Let's load Projectile, and:

 - globally ignore undo-files and similar byproducts.
 - toggle the =C-p p= and =C-p SPC= bindings (I find the latter easier to
   enter, and thus more adequate for "do what I mean");

TODO:

 - Could Projectile read ignore patterns from =~/.gitignore_global=?

#+begin_src emacs-lisp :tangle yes
  (want-drones projectile
               counsel-projectile)

  (projectile-global-mode)
  (counsel-projectile-mode)

  (setq projectile-globally-ignored-file-suffixes (append '(
                                                            ".un~"
                                                            ".~undo-tree~"
                                                            )
                                                          projectile-globally-ignored-files))

  (diminish 'projectile-mode)
#+end_src

I consider submodules to be separate projects, so don't include then
in the main file listing:

#+begin_src emacs-lisp :tangle yes
  (setq projectile-git-submodule-command nil)
#+END_SRC

** UI Utilities

*** Ace-window

#+begin_src emacs-lisp :tangle yes
  (want-drone ace-window)

  (with-eval-after-load 'ace-window
    ;; We make use of aw-ignored-buffers, so we need the eval-after-load
    (setq aw-scope 'frame
          aw-background nil

          aw-ignore-on t

          aw-ignored-buffers (append aw-ignored-buffers
                                     (mapcar (lambda (n) (format " *Minibuf-%s*" n))
                                             (number-sequence 0 20)))))

  (defun thblt/aw-switch-to-numbered-window (number)
    (aw-switch-to-window (nth (- number 1) (aw-window-list))))

  (defun thblt/switch-to-minibuffer ()
    "Switch to minibuffer window."
    (interactive)
    (if (active-minibuffer-window)
        (select-window (active-minibuffer-window))
      (error "Minibuffer is not active")))

  (general-define-key "C-x o" 'ace-window
                      ;; Emulate window-numbering
                      "M-0" 'thblt/switch-to-minibuffer)
                      ;; "M-1" (lambda () (interactive) (thblt/aw-switch-to-numbered-window 1))
                      ;; "M-2" (lambda () (interactive) (thblt/aw-switch-to-numbered-window 2))
                      ;; "M-3" (lambda () (interactive) (thblt/aw-switch-to-numbered-window 3))
                      ;; "M-4" (lambda () (interactive) (thblt/aw-switch-to-numbered-window 4))
                      ;; "M-5" (lambda () (interactive) (thblt/aw-switch-to-numbered-window 5))
                      ;; "M-6" (lambda () (interactive) (thblt/aw-switch-to-numbered-window 6))
                      ;; "M-7" (lambda () (interactive) (thblt/aw-switch-to-numbered-window 7))
                      ;; "M-8" (lambda () (interactive) (thblt/aw-switch-to-numbered-window 8))
                      ;; "M-9" (lambda () (interactive) (thblt/aw-switch-to-numbered-window 9)))
#+END_SRC

*** TODO Buffer management (ibuffer)

Rebind =C-x C-b= to =ibuffer= instead of =list-buffers=:

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

*** Eyebrowse

#+begin_src emacs-lisp :tangle yes
  (want-drone eyebrowse)

  (eyebrowse-mode)
#+END_SRC

*** Ivy

#+begin_src emacs-lisp :tangle yes
  (want-drone ivy)

  (setq ivy-use-virtual-buffers t)

  (ivy-mode)
  (diminish 'ivy-mode)

  (general-define-key
           "M-i"     'counsel-imenu
           "M-x"     'counsel-M-x
           "C-x C-f" 'counsel-find-file

           "C-S-s"   'swiper

           "C-x 8 RET" 'counsel-unicode-char)
#+end_src

*** Popwin

Popwin ‚Äúmakes you free from the hell of annoying buffers‚Äù:

#+begin_src emacs-lisp :tangle yes
  (want-drone popwin)

  (require 'popwin)
  (popwin-mode)
#+END_SRC

*** Which-key

#+begin_src emacs-lisp :tangle yes
  (want-drone which-key)

  (which-key-mode)
  (diminish 'which-key-mode)
#+end_src

*** Windmove

#+begin_src emacs-lisp :tangle yes
  (setq windmove-wrap-around t)

  (general-define-key
   "S-<up>" 'windmove-up
   "S-<left>" 'windmove-left
   "S-<right>" 'windmove-right
   "S-<down>" 'windmove-down)
#+END_SRC

*** Winner

#+begin_src emacs-lisp :tangle yes
  (winner-mode)
#+end_src

*** Customization helper

A little function to identify the face at point.  Nice to have when
writing themes, and faster than =C-u C-x ==.

#+begin_src emacs-lisp :tangle yes
  (defun what-face (pos)
    (interactive "d")
    (let ((face (or (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face))))
      (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+end_src

* DivINE: Modal editing

Because /DivINE Is Not [[https://github.com/emacs-evil/evil][Evil]]/, see?  DivINE is an extremely
simplified modal layer for Emacs, hand-cooked with selected, boon and
some hydras.

Like Evil, DivINE has text-objects (courtesy of Boon) and three
"modes" (normal, insert, visual), but it doesn't try to emulate Vim in
any way, although it stays quite close.  But ambiguous or misleading
mnemonics (eg, =y=) are replaced by their more natural Emacs
counterparts.  "=y=" is confusing because in Vim, to yank is to /copy/,
whereas Emacs uses the term and the binding for paste.  Hence, DivINE
uses =y= to paste, =,= to insert kill-ring, etc.

** DivINE

#+begin_src emacs-lisp :tangle yes
  ;; Divine

  (provide 'boon-keys)
  (require 'boon-core)
  (require 'selected)
  (require 'smartparens)

  ;;; Utility

  (defmacro Œª (&rest body)
    `(lambda (arg)
       (interactive "p")
       ,@body))

  (defmacro divine-argtimes (shift first repeated &rest then)
    `(progn
       ,first
       (--dotimes (cond
       ((null arg) 1)
       ((= 1 (abs arg)) arg)
       ((< 1 arg) (+ arg ,shift))
       ((> 1 arg) (- arg ,shift))
       (t (error "[thblt] Dafuk")))
         ,repeated)
       ,@then))

  ;;; Command Mode

  ;;;; basic motion

  (defmacro divine-make-jump-to-char (extra &optional backward)
    `(lambda (arg)
       (interactive "p")
       (re-search-forward
        (regexp-quote (char-to-string (read-char)))
        nil ;; FIXME bound at end of logical line
        t
        ,(if backward '(- arg) 'arg))
       (forward-char ,extra)))

  (define-key boon-moves-map "h" 'left-char)
  (define-key boon-moves-map "j" 'previous-line)
  (define-key boon-moves-map "k" 'next-line)
  (define-key boon-moves-map "l" 'right-char)

  (define-key boon-moves-map "w" 'forward-to-word)
  (define-key boon-moves-map "e" 'forward-word)
  (define-key boon-moves-map "b" 'backward-word)

  (define-key boon-moves-map "^" 'beginning-of-line-text)
  (define-key boon-moves-map "$" 'end-of-line)

  (define-key boon-moves-map "[" 'sp-backward-sexp)
  (define-key boon-moves-map "]" 'sp-forward-sexp)

  (define-key boon-moves-map "{" 'backward-paragraph)
  (define-key boon-moves-map "}" 'forward-paragraph)

  ;;;; search-like motion

  (define-key boon-moves-map "f" (divine-make-jump-to-char -1))
  (define-key boon-moves-map "F" (divine-make-jump-to-char 0 t))
  (define-key boon-moves-map "t" (divine-make-jump-to-char -2))
  (define-key boon-moves-map "T" (divine-make-jump-to-char +1 t))

  (define-key boon-command-map "/" 're-search-forward)

  ;;;; line operations

  (define-key boon-command-map "J" (Œª (divine-argtimes -1 nil (join-line -1))))
  (define-key boon-command-map "o" (Œª (divine-argtimes 0 nil (progn
                  (end-of-line)
                                                            (open-line 1)
                                                            (forward-line)))))
  (define-key boon-command-map "O" (Œª (divine-argtimes 0 nil (progn
                  (beginning-of-line)))))

  ;;;; leave command mode

  (define-key boon-command-map "i" 'boon-insert)
  (define-key boon-command-map "o" (lambda))
  (define-key boon-command-map "c" (Œª
            (call-interactively 'boon-take-region)
                                    (boon-insert)))


  ;;;; ???

  (define-prefix-command 'boon-forward-search-map)
  (define-prefix-command 'boon-backward-search-map)

  (define-key boon-forward-search-map " "  'isearch-forward)
  (define-key boon-forward-search-map "t"  'boon-qsearch-next-at-point)
  (define-key boon-forward-search-map "s"  'boon-qsearch-next-at-point)
  (define-key boon-forward-search-map "p"  'boon-qsearch-next)
  (define-key boon-forward-search-map "e"  'next-error)
  (define-key boon-forward-search-map "k"  'flycheck-next-error)
  (define-key boon-forward-search-map "b"  'next-buffer)
  (define-key boon-forward-search-map "u"  'mc/cycle-forward)

  (define-key boon-backward-search-map " "  'isearch-backward)
  (define-key boon-backward-search-map "t"  'boon-qsearch-previous-at-point)
  (define-key boon-backward-search-map "s"  'boon-qsearch-previous-at-point)
  (define-key boon-backward-search-map "p"  'boon-qsearch-previous)
  (define-key boon-backward-search-map "e"  'previous-error)
  (define-key boon-backward-search-map "k"  'flycheck-previous-error)
  (define-key boon-backward-search-map "b"  'previous-buffer)
  (define-key boon-backward-search-map "u"  'mc/cycle-backward)

  ;;;; goto

  (define-prefix-command 'divine-goto-map)
  ;;(set-keymap-parent divine-goto-map goto-map) @TODO What is that for?  What does that do?

  (defun divine-goto (&optional arg)
    (interactive "P")
    (if (null arg)
        (set-transient-map 'divine-goto-map)
        (push-mark)
        (goto-line arg)))

  (define-key boon-command-map "g" 'divine-goto)

  (define-key divine-goto-map "l" (lambda nil (interactive)
          (let ((linum linum-mode))
            (linum-mode 1)
            (call-interactively 'goto-line)
            (unless linum (linum-mode -1)))))
  (define-key divine-goto-map "=" 'find-tag)
  (define-key divine-goto-map "i" 'imenu)
  ;; @TODO g a [alternate] : toggles between header and source

  ;;;; delete

  (define-key boon-command-map "d" 'boon-take-region)

  ;;;; smartparens

  (define-key boon-command-map "!" 'divine-smartparens/body)

  (defhydra divine-smartparens (:hint nil)
    "Nav: hjkl"
      ("q" nil)
      ;; Decoration
      ("!" rainbow-delimiters-mode)

      ;; Navigation
      ("h" sp-backward-sexp)
      ("j" sp-down-sexp)
      ("k" sp-up-sexp)
      ("l" sp-forward-sexp )
      ("C-k" sp-backward-up-sexp)
      ("C-l" sp-backward-down-sexp)
      ;; Kill/copy
      ("w" sp-copy-sexp)
      ("W" sp-kill-sexp)
      ;; Misc
      ("t" sp-transpose-sexp)
      ("j" sp-join-sexp)
      ("s" sp-split-sexp)
      ("c" sp-convolute-sexp)
      ("i" sp-indent-defun)
      ;; Depth changing
      ("R" sp-splice-sexp)
      ("r" sp-splice-sexp-killing-around)
      ("<up>" sp-splice-sexp-killing-backward)
      ("<down>" sp-splice-sexp-killing-forward)
      ;; Barfing/slurping
      ("<right>" sp-forward-slurp-sexp)
      ("<left>" sp-forward-barf-sexp)
      ("C-<left>" sp-backward-barf-sexp)
      ("C-<right>" sp-backward-slurp-sexp))

  ;;;; narrowing

  (define-prefix-command 'divine-narrow-map)
  (define-key boon-command-map "n" 'divine-narrow-map)

  (define-key divine-narrow-map "d" 'narrow-to-defun)
  (define-key divine-narrow-map "p" 'narrow-to-page)
  (define-key divine-narrow-map "r" 'narrow-to-region)
  (define-key divine-narrow-map "b" 'org-narrow-to-block)
  (define-key divine-narrow-map "s" 'org-narrow-to-subtree)
  (define-key divine-narrow-map "e" 'org-narrow-to-element)
  (define-key divine-narrow-map "w" 'narrow-widen)

  ;;;; position cursor

  (define-prefix-command 'divine-recenter-map)
  (define-key boon-command-map "z" 'divine-recenter-map)

  (define-key divine-recenter-map "t" (Œª (recenter-top-bottom 1)))
  (define-key divine-recenter-map "z" 'recenter)
  (define-key divine-recenter-map "b" (Œª (recenter ;; Code from recenter-top-bottom
            (-
                                          -1
                                          (min
                                           (max 0 scroll-margin)
             (truncate (/ (window-body-height) 4.0)))))))

  ;;;; misc

  (define-key boon-command-map ";" 'evilnc-comment-or-uncomment-lines)

  (define-key boon-x-map "x" 'execute-extended-command)

  (define-key boon-select-map "@"  'boon-select-occurences)
  (define-key boon-select-map "#"  'boon-select-all)
  (define-key boon-select-map " "  'boon-select-line)

  (define-key boon-command-map "'" 'set-mark-command)
  (define-key boon-command-map [(return)] 'undefined)
  (define-key boon-command-map (kbd "<RET>") 'undefined)
  (define-key boon-command-map [(backspace)] 'undefined)
  (define-key boon-command-map (kbd "<DEL>") 'undefined)
  (define-key boon-command-map "`" 'boon-toggle-case)

  (define-key boon-command-map "u" 'undo)
  (dolist (number '("0" "1" "2" "3" "4" "5" "6" "7" "8" "9"))
    (define-key boon-command-map number 'digit-argument))
  (define-key boon-command-map "~" 'universal-argument)

  (define-key boon-command-map " " 'boon-drop-mark)
  (define-key boon-command-map [escape] 'boon-quit)

  ;; Special mode rebinds
  (define-key boon-special-map "`" 'boon-quote-character)
  (define-key boon-special-map "'" 'boon-quote-character)
  (define-key boon-special-map "x" boon-x-map)
  (define-key boon-special-map [escape] 'boon-set-command-state)

  ;;  Insert mode rebinds
  (define-key boon-insert-map [remap newline] 'boon-newline-dwim)

  (define-key boon-insert-map [escape] 'boon-set-command-state)

  ;; Global rebinds
  (define-key global-map [escape] 'keyboard-quit)
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  (define-key isearch-mode-map [escape] 'isearch-abort)

  (provide 'boon-keys)

  ;; (define-key boon-select-map "q"  'boon-select-outside-quotes)
  (define-key boon-select-map "w"  'boon-select-word)
  ;; (define-key boon-select-map "g"  'boon-select-paragraph)

  ;; (define-key boon-select-map "a"  'boon-select-borders) ;; Around
  ;; (define-key boon-select-map "s"  'boon-select-wim) ;; symbol
  ;; (define-key boon-select-map "v"  'boon-select-with-spaces)
  ;; (define-key boon-select-map "d"  'boon-select-document)

  ;; (define-key boon-select-map "C"  'boon-select-comment)
  ;; (define-key boon-select-map "x"  'boon-select-outside-pairs) ;; eXpression
  ;; (define-key boon-select-map "c"  'boon-select-inside-pairs) ;; Contents

  ;; (define-key boon-select-map "y"  'boon-select-content) ;; inZide

  ;; (define-key boon-select-map "b"  'boon-select-blanks) ;; blanKs


  ;; (define-key boon-moves-map "n" '("noon walk" . boon-switch-mark))
  ;; (define-key boon-moves-map "N" 'xref-pop-marker-stack)

  ;; (define-key boon-moves-map "z"  '("fYnd" . xref-find-definitions))
  ;; (define-key boon-moves-map "Z"  'xref-find-references)
  ;; (define-key boon-moves-map "i"  'previous-line)
  ;; (define-key boon-moves-map "o"  'next-line)
  ;; (define-key boon-moves-map "I"  'backward-paragraph)
  ;; (define-key boon-moves-map "O"  'forward-paragraph)
  ;; (define-key boon-moves-map "u"  'boon-beginning-of-line)
  ;; (define-key boon-moves-map "p"  'boon-end-of-line)
  ;; (define-key boon-moves-map "j"  'boon-smarter-backward)
  ;; (define-key boon-moves-map "√∂"  'boon-smarter-forward)
  ;; (define-key boon-moves-map "K"  'boon-smarter-upward)
  ;; (define-key boon-moves-map "L"  'boon-smarter-downward)
  ;; (define-key boon-moves-map ","  'boon-beginning-of-expression)
  ;; (define-key boon-moves-map "."  'boon-end-of-expression)
  ;; (define-key boon-moves-map "k"  'backward-char)
  ;; (define-key boon-moves-map "l"  'forward-char)
  ;; (define-key boon-moves-map "<"  'beginning-of-buffer)
  ;; (define-key boon-moves-map ">"  'end-of-buffer)
  ;; (define-key boon-moves-map "h"  '("hop" . avy-goto-word-1))
  ;; (define-key boon-moves-map "H"  'avy-goto-char)



  ;; ;; Special keys

  ;; ;; LEFT HAND

  ;; ;; Top row
  ;; ;; q
  ;; (define-key boon-command-map "q" '("quote" . boon-quote-character))

  ;; ;; w,e
  ;; ;; where is? elsewhere?
  (define-key boon-moves-map "w" '("where was?" . boon-backward-search-map))
  (define-key boon-moves-map "e" '("elsewhere?" . boon-forward-search-map))

  ;; (define-key boon-moves-map "ww"  'boon-qsearch-previous)
  ;; (define-key boon-moves-map "ee"  'boon-qsearch-next)

  ;; (define-key boon-moves-map "W"  'boon-qsearch-previous)
  ;; (define-key boon-moves-map "E"  'boon-qsearch-next)

  ;; ;; r
  ;; (define-key boon-command-map "r" '("occuR" . occur))
  ;; (define-key boon-command-map "R" 'kmacro-start-macro) ; Record

  ;; ;; Misc crap
  ;; (define-key boon-command-map "P" 'kmacro-end-or-call-macro) ; Play
  ;; (define-key boon-command-map "X" 'boon-highlight-regexp)

  ;; ;; t
  ;; (define-key boon-command-map "t" '("transform" . boon-replace-by-character))


  ;; ;; home row
  ;; ;; a
  ;; (define-key boon-command-map "a" '("around" . boon-enclose))

  ;; ;; s
  ;; (define-key boon-command-map "s" '("substitute" . boon-substitute-region))

  ;; ;; d
  ;; (define-key boon-command-map "d" '("delete" . boon-take-region)) ; "delete"
  ;; (define-key boon-command-map "D" 'boon-treasure-region) ; "duplicate"

  ;; ;; f
  ;; (define-key boon-command-map "f" '("fetch" . boon-splice))
  ;; (define-key boon-command-map "F" 'yank-pop)

  ;; ;; g


  ;; ;; Bottom row
  ;; ;; z
  ;; (define-key boon-command-map "y" '("repeat" . boon-repeat-command))
  ;; ;; x
  ;; (define-key boon-command-map "x" 'boon-x-map)
  ;; ;; c
  ;; (define-key boon-command-map "c" 'boon-c-god)
  ;; ;; v
  ;; (define-key boon-command-map (kbd "C-v") 'boon-open-line-and-insert)
  ;; (define-key boon-command-map "V" 'boon-open-next-line-and-insert)
  ;; (define-key boon-command-map "v" '("v looks like an insert mark" . boon-set-insert-like-state))
  ;; ;; b
  ;; (define-key boon-command-map "B" 'boon-copy-to-register) ; bank
  ;; (define-key boon-command-map "b" 'insert-register)

  ;; ;; RIGHT HAND: movement and marking commands.
  ;; ;; Most of these are actually in the boon-moves-map; however some don't quite work there; so they end up here.
  ;; (define-key boon-command-map (kbd "C-k") 'scroll-down-line)
  ;; (define-key boon-command-map (kbd "C-l") 'scroll-up-line)

  ;; (define-key indent-rigidly-map "k" 'indent-rigidly-right)
  ;; (define-key indent-rigidly-map "l" 'indent-rigidly-left)

  ;;; Visual mode

  (define-key selected-keymap (kbd "r") #'rectangle-mark-mode)
  (define-key selected-keymap (kbd "h") #'exchange-point-and-mark)
  (define-key selected-keymap (kbd "k") #'kill-region)
  (define-key selected-keymap (kbd "'") #'deactivate-mark)
  (define-key selected-keymap (kbd "n") #'narrow-to-region)
  (define-key selected-keymap (kbd "x") #'er/expand-region)
  (define-key selected-keymap (kbd "e") #'eval-region)

  (require 'boon)
  (add-hook 'prog-mode-hook 'boon-local-mode)
  (add-hook 'text-mode-hook 'boon-local-mode)
  (add-hook 'conf-mode-hook 'boon-local-mode)
  (selected-global-mode)

#+end_src

Selected is a package which allows to create specific bindings when
region is active:

#+begin_src emacs-lisp :tangle yes
  (want-drone selected)

  (defvar selected-org-mode-map (make-sparse-keymap))
  (selected-global-mode)
  (diminish 'selected-minor-mode)
#+end_src

** Cheatsheet generator

* Editing text

This chapter deals with /general/ text editing.  The next two configure
prose and code editing, respectively.

** Spell checking

Use =aspell= instead of =ispell=:

#+begin_src emacs-lisp :tangle yes
  (setq ispell-program-name "aspell")
#+end_src

Don't ask before saving custom dict:

#+begin_src emacs-lisp :tangle yes
  (setq ispell-silently-savep t)
#+end_src

And enable Flyspell:

#+begin_src emacs-lisp :tangle yes
  (add-hook 'text-mode-hook (lambda () (flyspell-mode t)))

  (diminish 'flyspell-mode "Fly")
#+end_src

Disable horrible and confusing Flyspell "duplicate" marks.  These are
easily confused with actually misspelled words, but M-$ won't work on
them, and would "correct" another word, possibly off-screen.

#+begin_src emacs-lisp :tangle yes
  (setq flyspell-duplicate-distance 0)
#+END_SRC

Correct words using Ivy instead of default method:

#+begin_src emacs-lisp :tangle yes
  (want-drone flyspell-correct)
  (require 'flyspell-correct-ivy)

  (general-define-key :keymaps 'flyspell-mode-map
                      "M-$" 'flyspell-auto-correct-previous-word
                      "C-;" 'flyspell-correct-previous-word-generic)
#+end_src

** Moving around

*** avy

#+begin_src emacs-lisp :tangle yes
  (want-drone avy)

  (general-define-key "C-:" 'avy-goto-char-timer
                      "M-g f" 'avy-goto-line)
#+END_SRC

*** beginend

#+begin_src emacs-lisp :tangle yes
  (require 'beginend)
  (beginend-global-mode)
   (mapc (lambda (m) (diminish (cdr m)))
        beginend-modes)
  (diminish 'beginend-global-mode)
#+end_src

*** mwim

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C-a") 'mwim-beginning-of-code-or-line)
  (global-set-key (kbd "C-e") 'mwim-end-of-code-or-line)
  (global-set-key (kbd "<home>") 'mwim-beginning-of-line-or-code)
  (global-set-key (kbd "<end>") 'mwim-end-of-line-or-code)
#+END_SRC

*** nav-flash (don't get lost)

#+begin_src emacs-lisp :tangle yes
  (require 'nav-flash)

  (face-spec-set 'nav-flash-face '((t (:inherit pulse-highlight-face))))

  (advice-add 'recenter-top-bottom :after (lambda (x) (nav-flash-show)))
#+END_SRC

** Replace

#+begin_src emacs-lisp :tangle yes
  (want-drone visual-regexp)

  (general-define-key
           "C-M-%" 'vr/query-replace
           "C-c r" 'vr/replace
           "C-c m" 'vr/mc-mark)
#+END_SRC

** Minor modes

*** Auto-revert-mode

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'autorevert
    (diminish 'auto-revert-mode "üîÉ"))
#+end_src

*** TODO Expand-region

#+begin_src emacs-lisp :tangle yes
  (want-drone expand-region)
#+end_src

*** Move text

Move lines of text with =M-<up>= and =M-<down>=.

#+begin_src emacs-lisp :tangle yes
  (want-drone move-text)

  (move-text-default-bindings)
#+end_src

*** Multiple cursors

#+begin_src emacs-lisp :tangle yes
  (want-drone multiple-cursors)

  (add-hook 'prog-mode-hook (lambda () (multiple-cursors-mode t)))
  (add-hook 'text-mode-hook (lambda () (multiple-cursors-mode t)))
  (general-define-key "C-S-c C-S-c" 'mc/edit-lines)
#+end_src

*** Recentf

#+begin_src emacs-lisp :tangle yes
  (recentf-mode)
#+end_src

*** TODO Smartparens

#+begin_src emacs-lisp :tangle yes
  (want-drone smartparens)
  (require 'smartparens-config) ;; Load default config

  (smartparens-global-mode)
  (show-smartparens-global-mode)

  (diminish 'smartparens-mode)
#+end_src

**** Bindings

Since the author of Smartparens released [[https://github.com/Fuco1/.emacs.d/blob/master/files/smartparens.el][his own config]], here it is,
copy-pasted and slightly modified to suit my needs:

#+begin_src emacs-lisp :tangle yes
  (add-hook 'minibuffer-setup-hook 'turn-on-smartparens-strict-mode)


  (general-define-key :map smartparens-mode-map
                      "C-M-f" 'sp-forward-sexp

                      "C-M-b" 'sp-backward-sexp

                      "C-M-d" 'sp-down-sexp
                      "C-M-a" 'sp-backward-down-sexp
                      "C-S-d" 'sp-beginning-of-sexp
                      "C-S-a" 'sp-end-of-sexp

                      "C-M-e" 'sp-up-sexp
                      "C-M-u" 'sp-backward-up-sexp
                      "C-M-t" 'sp-transpose-sexp

                      "C-M-n" 'sp-next-sexp
                      "C-M-p" 'sp-previous-sexp

                      "C-M-k" 'sp-kill-sexp
                      "C-M-w" 'sp-copy-sexp

                      "M-<delete>" 'sp-unwrap-sexp
                      "M-<backspace>" 'sp-backward-unwrap-sexp

                      "C-<right>" 'sp-forward-slurp-sexp
                      "C-<left>" 'sp-forward-barf-sexp
                      "C-M-<left>" 'sp-backward-slurp-sexp
                      "C-M-<right>" 'sp-backward-barf-sexp

                      "M-D" 'sp-splice-sexp
                      "C-M-<delete>" 'sp-splice-sexp-killing-forward
                      "C-M-<backspace>" 'sp-splice-sexp-killing-backward
                      "C-S-<backspace>" 'sp-splice-sexp-killing-around

                      "C-]" 'sp-select-next-thing-exchange
                      "C-<left_bracket>" 'sp-select-previous-thing
                      "C-M-]" 'sp-select-next-thing

                      "M-F" 'sp-forward-symbol
                      "M-B" 'sp-backward-symbol

                      "C-c f" (lambda () (interactive) (sp-beginning-of-sexp 2))
                      "C-c b" (lambda () (interactive) (sp-beginning-of-sexp -2))

                      "C-M-s"
                      (defhydra smartparens-hydra ()
                        "Smartparens"
                        ("d" sp-down-sexp "Down")
                        ("e" sp-up-sexp "Up")
                        ("u" sp-backward-up-sexp "Up")
                        ("a" sp-backward-down-sexp "Down")
                        ("f" sp-forward-sexp "Forward")
                        ("b" sp-backward-sexp "Backward")
                        ("k" sp-kill-sexp "Kill" :color blue)
                        ("q" nil "Quit" :color blue)))


  ;; (bind-key "H-t" 'sp-prefix-tag-object smartparens-mode-map)
  ;; (bind-key "H-p" 'sp-prefix-pair-object smartparens-mode-map)
  ;; (bind-key "H-y" 'sp-prefix-symbol-object smartparens-mode-map)
  ;; (bind-key "H-h" 'sp-highlight-current-sexp smartparens-mode-map)
  ;; (bind-key "H-e" 'sp-prefix-save-excursion smartparens-mode-map)
  ;; (bind-key "H-s c" 'sp-convolute-sexp smartparens-mode-map)
  ;; (bind-key "H-s a" 'sp-absorb-sexp smartparens-mode-map)
  ;; (bind-key "H-s e" 'sp-emit-sexp smartparens-mode-map)
  ;; (bind-key "H-s p" 'sp-add-to-previous-sexp smartparens-mode-map)
  ;; (bind-key "H-s n" 'sp-add-to-next-sexp smartparens-mode-map)
  ;; (bind-key "H-s j" 'sp-join-sexp smartparens-mode-map)
  ;; (bind-key "H-s s" 'sp-split-sexp smartparens-mode-map)
  ;; (bind-key "H-s r" 'sp-rewrap-sexp smartparens-mode-map)
  ;; (defvar hyp-s-x-map)
  ;; (define-prefix-command 'hyp-s-x-map)
  ;; (bind-key "H-s x" hyp-s-x-map smartparens-mode-map)
  ;; (bind-key "H-s x x" 'sp-extract-before-sexp smartparens-mode-map)
  ;; (bind-key "H-s x a" 'sp-extract-after-sexp smartparens-mode-map)
  ;; (bind-key "H-s x s" 'sp-swap-enclosing-sexp smartparens-mode-map)

  ;; (bind-key "C-x C-t" 'sp-transpose-hybrid-sexp smartparens-mode-map)

  ;; (bind-key ";" 'sp-comment emacs-lisp-mode-map)

  ;; (bind-key [remap c-electric-backspace] 'sp-backward-delete-char smartparens-strict-mode-map)

  ;; ;;;;;;;;;;;;;;;;;;
  ;; ;; pair management

  ;; (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
  ;; (bind-key "C-(" 'sp---wrap-with-40 minibuffer-local-map)

  ;; ;;; markdown-mode
  ;; (sp-with-modes '(markdown-mode gfm-mode rst-mode)
  ;;   (sp-local-pair "*" "*"
  ;;                  :wrap "C-*"
  ;;                  :unless '(sp--gfm-point-after-word-p sp-point-at-bol-p)
  ;;                  :post-handlers '(("[d1]" "SPC"))
  ;;                  :skip-match 'sp--gfm-skip-asterisk)
  ;;   (sp-local-pair "**" "**")
  ;;   (sp-local-pair "_" "_" :wrap "C-_" :unless '(sp-point-after-word-p)))

  ;; (defun sp--gfm-point-after-word-p (id action context)
  ;;   "Return t if point is after a word, nil otherwise.
  ;; This predicate is only tested on \"insert\" action."
  ;;   (when (eq action 'insert)
  ;;     (sp--looking-back-p (concat "\\(\\sw\\)" (regexp-quote id)))))

  ;; (defun sp--gfm-skip-asterisk (ms mb me)
  ;;   (save-excursion
  ;;     (goto-char mb)
  ;;     (save-match-data (looking-at "^\\* "))))

  ;; ;;; rst-mode
  ;; (sp-with-modes 'rst-mode
  ;;   (sp-local-pair "``" "``"))

  ;; ;;; org-mode
  ;; (sp-with-modes 'org-mode
  ;;   (sp-local-pair "*" "*" :actions '(insert wrap) :unless '(sp-point-after-word-p sp-point-at-bol-p) :wrap "C-*" :skip-match 'sp--org-skip-asterisk)
  ;;   (sp-local-pair "_" "_" :unless '(sp-point-after-word-p) :wrap "C-_")
  ;;   (sp-local-pair "/" "/" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
  ;;   (sp-local-pair "~" "~" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
  ;;   (sp-local-pair "=" "=" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
  ;;   (sp-local-pair "¬´" "¬ª"))

  ;; (defun sp--org-skip-asterisk (ms mb me)
  ;;   (or (and (= (line-beginning-position) mb)
  ;;            (eq 32 (char-after (1+ mb))))
  ;;       (and (= (1+ (line-beginning-position)) me)
  ;;            (eq 32 (char-after me)))))

  ;; ;;; tex-mode latex-mode
  ;; (sp-with-modes '(tex-mode plain-tex-mode latex-mode)
  ;;   (sp-local-tag "i" "\"<" "\">"))

  ;; ;;; lisp modes
  ;; (sp-with-modes sp--lisp-modes
  ;;   (sp-local-pair "(" nil
  ;;                  :wrap "C-("
  ;;                  :pre-handlers '(my-add-space-before-sexp-insertion)
  ;;                  :post-handlers '(my-add-space-after-sexp-insertion)))



  ;; (defun my-add-space-after-sexp-insertion (id action _context)
  ;;   (when (eq action 'insert)
  ;;     (save-excursion
  ;;       (forward-char (sp-get-pair id :cl-l))
  ;;       (when (or (eq (char-syntax (following-char)) ?w)
  ;;                 (looking-at (sp--get-opening-regexp)))
  ;;         (insert " ")))))

  ;; (defun my-add-space-before-sexp-insertion (id action _context)
  ;;   (when (eq action 'insert)
  ;;     (save-excursion
  ;;       (backward-char (length id))
  ;;       (when (or (eq (char-syntax (preceding-char)) ?w)
  ;;                 (and (looking-back (sp--get-closing-regexp))
  ;;                      (not (eq (char-syntax (preceding-char)) ?'))))
  ;;         (insert " ")))))

  ;; ;;; C++
  ;; (sp-with-modes '(malabar-mode c++-mode)
  ;;   (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET"))))
  ;; (sp-local-pair 'c++-mode "/*" "*/" :post-handlers '((" | " "SPC")
  ;;                                                     ("* ||\n[i]" "RET")))

  ;; ;;; PHP
  ;; (sp-with-modes '(php-mode)
  ;;   (sp-local-pair "/**" "*/" :post-handlers '(("| " "SPC")
  ;;                                              (my-php-handle-docstring "RET")))
  ;;   (sp-local-pair "/*." ".*/" :post-handlers '(("| " "SPC")))
  ;;   (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
  ;;   (sp-local-pair "(" nil :prefix "\\(\\sw\\|\\s_\\)*"))

  ;; (defun my-php-handle-docstring (&rest _ignored)
  ;;   (-when-let (line (save-excursion
  ;;                      (forward-line)
  ;;                      (thing-at-point 'line)))
  ;;     (cond
  ;;      ;; variable
  ;;      ((string-match (rx (or "private" "protected" "public" "var") (1+ " ") (group "$" (1+ alnum))) line)
  ;;       (let ((var-name (match-string 1 line))
  ;;             (type ""))
  ;;         ;; try to guess the type from the constructor
  ;;         (-when-let (constructor-args (my-php-get-function-args "__construct" t))
  ;;           (setq type (or (cdr (assoc var-name constructor-args)) "")))
  ;;         (insert "* @var " type)
  ;;         (save-excursion
  ;;           (insert "\n"))))
  ;;      ((string-match-p "function" line)
  ;;       (save-excursion
  ;;         (let ((args (save-excursion
  ;;                       (forward-line)
  ;;                       (my-php-get-function-args nil t))))
  ;;           (--each args
  ;;             (when (my-php-should-insert-type-annotation (cdr it))
  ;;               (insert (format "* @param %s%s\n"
  ;;                               (my-php-translate-type-annotation (cdr it))
  ;;                               (car it))))))
  ;;         (let ((return-type (save-excursion
  ;;                              (forward-line)
  ;;                              (my-php-get-function-return-type))))
  ;;           (when (my-php-should-insert-type-annotation return-type)
  ;;             (insert (format "* @return %s\n" (my-php-translate-type-annotation return-type))))))
  ;;       (re-search-forward (rx "@" (or "param" "return") " ") nil t))
  ;;      ((string-match-p ".*class\\|interface" line)
  ;;       (save-excursion (insert "\n"))
  ;;       (insert "* ")))
  ;;     (let ((o (sp--get-active-overlay)))
  ;;       (indent-region (overlay-start o) (overlay-end o)))))
#+END_SRC

*** Undo-tree

#+begin_src emacs-lisp :tangle yes
  (want-drone undo-tree)

  (setq undo-tree-auto-save-history t
        undo-tree-visualizer-diff nil)

  (global-undo-tree-mode)
  (diminish 'undo-tree-mode)
#+end_src

*** Unfill

#+begin_src emacs-lisp :tangle yes
  (want-drone unfill)

  (define-key selected-keymap (kbd "M-Q") 'unfill-region)
#+END_SRC

*** Yasnippet

#+begin_src emacs-lisp :tangle yes
  (want-drone yasnippet)

  (yas-global-mode)
  (diminish 'yas-minor-mode)
#+end_src

** Misc customizations

*** Use C-h as backspace

#+begin_src emacs-lisp :tangle yes
  (general-define-key "C-h" 'delete-backward-char)
#+END_SRC

*** TODO Autosave when losing focus

This is the initial version, which works perfectly well:

#+begin_src emacs-lisp :tangle yes
  (add-hook 'focus-out-hook
            (lambda ()
              (save-some-buffers t)))
#+end_src

*** Delete trailing whitespace when saving

#+begin_src emacs-lisp :tangle yes
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

*** Diff files before marking a buffer modified

Ignore modification-time-only changes in files, i.e. ones that don't
really change the contents.  This happens often with switching between
different VC buffers.  Code comes from [[http://stackoverflow.com/a/29556894][this StackOverflow question]].

#+begin_src emacs-lisp :tangle yes
  (defun update-buffer-modtime-if-byte-identical ()
    (let* ((size      (buffer-size))
           (byte-size (position-bytes size))
           (filename  buffer-file-name))
      (when (and byte-size (<= size 1000000))
        (let* ((attributes (file-attributes filename))
               (file-size  (nth 7 attributes)))
          (when (and file-size
                     (= file-size byte-size)
                     (string= (buffer-substring-no-properties 1 (1+ size))
                              (with-temp-buffer
                                (insert-file-contents filename)
                                (buffer-string))))
            (set-visited-file-modtime (nth 5 attributes))
            t)))))

  (defun verify-visited-file-modtime--ignore-byte-identical (original &optional buffer)
    (or (funcall original buffer)
        (with-current-buffer buffer
          (update-buffer-modtime-if-byte-identical))))
  (advice-add 'verify-visited-file-modtime :around #'verify-visited-file-modtime--ignore-byte-identical)

  (defun ask-user-about-supersession-threat--ignore-byte-identical (original &rest arguments)
    (unless (update-buffer-modtime-if-byte-identical)
      (apply original arguments)))
  (advice-add 'ask-user-about-supersession-threat :around #'ask-user-about-supersession-threat--ignore-byte-identical)

#+end_src

* Writing prose
:PROPERTIES:
:CUSTOM_ID: writing-prose
:END:

This section deals with two things:

 1. Major modes dedicated to writing prose, as opposed to code or
    configuration.
 2. Non-code bits in code/configuration files: comments and integrated
    documentation.

** The text-mode hydra

TODO validate =:= and ~=~ on all keyboard mappings.

#+begin_src emacs-lisp :tangle yes
  (setq visual-fill-column-width fill-column)

  (defhydra hydra-text-mode ()
    "text-mode switches"
    ("f" flyspell-mode "Flyspell")
    ("d" ispell-change-dictionary "Language")
    ("w" visual-fill-column-mode "Visual fill column")
    ("," text-scale-decrease "Decrease font size")
    (";" text-scale-increase "Increase font size")
    (":" (lambda () (interactive) (setq-local visual-fill-column-width (- visual-fill-column-width 5))) "Decrease width")
    ("!" (lambda () (interactive) (setq-local visual-fill-column-width (+ visual-fill-column-width 5))) "Decrease width"))


  (general-define-key :keymaps 'text-mode-map
                      "C-x w" 'hydra-text-mode/body)
#+END_SRC

** Common settings and minor modes
*** Abbrev

#+begin_src emacs-lisp :tangle yes
  (add-hook 'text-mode-hook (lambda () (abbrev-mode t)))
  (diminish 'abbrev-mode)
#+end_src

*** Unfill

#+begin_src emacs-lisp :tangle yes
  (want-drone unfill)
  (general-define-key "M-Q" 'unfill-paragraph)
#+end_src

*** Wordwrap/visual line/visual-fill-column

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'simple
    (diminish 'visual-line-mode))

  (want-drone visual-fill-column)
  (require 'visual-fill-column)

  (dolist (hook '(markdown-mode-hook org-mode-hook))
    (add-hook hook (lambda () (setq visual-fill-column-center-text t))))
#+end_src

** Major modes

#+begin_src emacs-lisp :tangle yes
  (want-drone markdown-mode)
#+end_src

*** AucTex

#+begin_src emacs-lisp :tangle yes
  (want-drones auctex
               company-auctex)

  (add-hook 'LaTeX-mode-hook (lambda ()
                               (visual-line-mode t)
                               (TeX-fold-mode t)))

  (progn
    (setq-default TeX-save-query nil      ; Autosave
                  TeX-parse-self t
                  TeX-engine 'xetex
                  TeX-source-correlate-mode t)) ;; Synctex on

  (with-eval-after-load 'reftex-vars
    (progn
      ;; (also some other reftex-related customizations)
      (setq reftex-cite-format
            '((?\C-m . "\\cite[]{%l}")
              (?f . "\\footcite[][]{%l}")
              (?t . "\\textcite[q]{%l}")
              (?p . "\\parencite[]{%l}")
              (?o . "\\citepr[]{%l}")
              (?n . "\\nocite{%l}")))))
#+end_src

*** Org-mode

#+begin_src emacs-lisp :tangle yes
  (want-drone htmlize
              org
              org-download)

  (setq org-catch-invisible-edits t
        org-hide-leading-stars t
        org-hide-emphasis-markers t
        org-html-htmlize-output-type 'css
        org-imenu-depth 8
        org-src-fontify-natively t
        org-ellipsis " ‚ñº")

  (add-hook 'org-mode-hook (lambda ()
                             (org-indent-mode t)
                             (visual-line-mode t)
                             (which-function-mode t)))

  (with-eval-after-load 'org-indent
    (diminish 'org-indent-mode)
    )
#+end_src

Configure smartparens:

#+begin_src emacs-lisp :tangle yes
  (sp-with-modes 'org-mode
    (sp-local-pair "*" "*" :actions '(insert wrap) :unless '(sp-point-after-word-p sp-point-at-bol-p) :wrap "C-*" :skip-match 'sp--org-skip-asterisk)
    (sp-local-pair "_" "_" :unless '(sp-point-after-word-p) :wrap "C-_")
    (sp-local-pair "/" "/" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "~" "~" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "=" "=" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC"))))

  (defun sp--org-skip-asterisk (ms mb me)
    (or (and (= (line-beginning-position) mb)
             (eq 32 (char-after (1+ mb))))
        (and (= (1+ (line-beginning-position)) me)
             (eq 32 (char-after me)))))
#+END_SRC

Some cool org extensions:

 - =toc-org= provides, guess what, automatic TOC generation for
   org-mode.  This is better [[https://github.com/snosov1/toc-org/issues/20#issuecomment-276407541][pinned to melpa-stable]].

#+begin_src emacs-lisp :tangle yes
  (want-drone toc-org)
  (add-hook 'org-mode-hook 'toc-org-enable)
#+END_SRC

Identify position in buffer:

#+begin_src emacs-lisp :tangle yes
  (defun thblt/org-where-am-i ()
    "Return a string of headers indicating where point is in the current tree."
    (interactive)
    (let (headers)
      (save-excursion
  (while (condition-case nil
       (progn
         (push (nth 4 (org-heading-components)) headers)
         (outline-up-heading 1))
     (error nil))))
  (message (mapconcat #'identity headers " > "))))

  (general-define-key :keymaps 'org-mode-map
                      "<f1> <f1>" 'thblt/org-where-am-i)
#+END_SRC

The *emphasize selected* bindings:

#+begin_src emacs-lisp :tangle yes
  (define-key selected-org-mode-map (kbd "b") (lambda () (interactive) (org-emphasize ?*)))
  (define-key selected-org-mode-map (kbd "i") (lambda () (interactive) (org-emphasize ?/)))
#+END_SRC

**** Org-agenda:

#+begin_src emacs-lisp :tangle yes
  (setq org-agenda-files (list "~/Documents/LOG.org")
        org-default-notes-file "~/Documents/LOG.org")
#+end_src

**** Org-babel

#+begin_src emacs-lisp :tangle yes
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((dot . t)
       (shell . t)))
#+END_SRC

**** Org-ref

#+begin_src emacs-lisp :tangle yes
  (want-drone org-ref
              :with (helm-bibtex :with (biblio)))

  (setq org-ref-completion-library 'org-ref-ivy-cite
        bibtex-dialect 'biblatex)

  ;; org-ref must have been (require)d to work.

  (add-hook 'org-mode-hook (lambda () (require 'org-ref)))
#+END_SRC

* Writing code
** Settings

Some basic settings...

#+begin_src emacs-lisp :tangle yes
  (setq-default comment-empty-lines nil
	        tab-width 2
	        c-basic-offset 2
	        cperl-indent-level 2
	        indent-tabs-mode nil)
#+end_src

and a few mappings.

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "<f8>") 'ffap)
  (global-set-key (kbd "<f5>") 'recompile)
#+end_src

** Minor modes

#+begin_src emacs-lisp :tangle yes
  (want-drones rainbow-delimiters)
#+END_SRC

*** Color-identifiers

#+begin_src emacs-lisp :tangle yes
  (want-drone color-identifiers-mode)

  (add-hook 'prog-mode-hook 'color-identifiers-mode)
  (advice-add 'load-theme :after (lambda (&rest _)
                                   (color-identifiers:regenerate-colors)
                                   (color-identifiers:refresh)))

  (with-eval-after-load 'color-identifiers-mode
    (diminish 'color-identifiers-mode))
#+end_src

*** Company

#+begin_src emacs-lisp :tangle yes
  (want-drone company)

  (add-hook 'prog-mode-hook 'company-mode)
  ;;TODO BIND  :bind (:map company-mode-map
  ;; (("M-TAB" . company-complete-common)))
  (with-eval-after-load 'company
    (diminish 'company-mode))
#+end_src

*** Editorconfig

#+begin_src emacs-lisp :tangle yes
  (want-drone editorconfig)

  (add-hook 'prog-mode-hook (editorconfig-mode 1))
  (add-hook 'text-mode-hook (editorconfig-mode 1))
  (with-eval-after-load 'editorconfig
    (diminish 'editorconfig-mode))
#+end_src

*** Evil Nerd Commenter

A good replacement for ~comment-dwim~, but unline [[https://github.com/remyferre/comment-dwim-2][~comment-dwim2~]], it
can't alternate between commenting and commenting /out/ (adding the
comment delimiter at the start or the end of the line).

#+begin_src emacs-lisp :tangle yes
  (want-drone evil-nerd-commenter)
  (general-define-key "M-;"   'evilnc-comment-or-uncomment-lines
                      "C-M-;" 'evilnc-comment-or-uncomment-paragraphs
                      "C-c l" 'evilnc-quick-comment-or-uncomment-to-the-line
                      "C-c c" 'evilnc-copy-and-comment-lines
                      "C-c p" 'evilnc-comment-or-uncomment-paragraphs)
#+end_src

*** Flycheck

#+begin_src emacs-lisp :tangle yes
  (want-drones flycheck
               flycheck-pos-tip pos-tip
               )

    (add-hook 'prog-mode-hook 'flycheck-mode)

    (with-eval-after-load 'flycheck
      (diminish 'flycheck-mode))
#+end_src

Use popups instead of the mode-line to display flycheck errors:

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'flycheck
    (flycheck-pos-tip-mode))
#+end_src

*** Helm-dash

#+begin_src emacs-lisp :tangle yes
  (want-drone helm-dash)

  (setq helm-dash-docsets-path "~/.local/share/DashDocsets")

  (add-hook 'c-mode-hook
            (lambda ()
              (setq-local helm-dash-docsets '("C"))

              (add-hook 'c++-mode-hook
                        (lambda ()
                          (setq-local helm-dash-docsets '("Boost" "C++" "Qt"))))

              (add-hook 'emacs-lisp-mode-hook
                        (lambda ()
                          (setq-local helm-dash-docsets '("Emacs Lisp"))))

              (add-hook 'haskell-mode-hook
                        (lambda ()
                          (setq-local helm-dash-docsets '("Haskell"))))

              (add-hook 'html-mode-hook
                        (lambda ()
                          (setq-local helm-dash-docsets '("HTML"))))

              (add-hook 'js-mode-hook
                        (lambda ()
                          (setq-local helm-dash-docsets '("JavaScript"))))

              (add-hook 'python-mode-hook
                        (lambda ()
                          (setq-local helm-dash-docsets '("Python 2" "Python 3"))))

              (add-hook 'rust-mode-hook
                        (lambda ()
                          (setq-local helm-dash-docsets '("Rust"))))))

  (general-define-key :keymaps 'prog-mode-map
                    "<f1> <f1>" 'helm-dash-at-point)
#+end_src

*** Highlight-indent-guides

#+begin_src emacs-lisp :tangle yes
  (want-drone highlight-indent-guides)

  (setq highlight-indent-guides-method 'character
        highlight-indent-guides-character ?‚îÉ
        highlight-indent-guides-auto-character-face-perc 25)

  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
#+end_src

*** Outline and Outshine

#+begin_src emacs-lisp :tangle yes
  (want-drone outshine)

  (add-hook 'prog-mode-hook 'outline-minor-mode)
  (add-hook 'outline-minor-mode-hook 'outshine-minor-mode)
#+END_SRC

*** Rainbow mode

Rainbow mode is similar to Atom's Pigments plugin or something.

#+begin_src emacs-lisp :tangle yes
  (want-drones kurecolor
               rainbow-mode)
  (add-hook 'prog-mode-hook (rainbow-mode))
  (add-hook 'css-mode-hook 'rainbow-mode)
  (add-hook 'scss-mode-hook 'rainbow-mode)

  (with-eval-after-load 'rainbow-mode
    (diminish 'rainbow-mode))
#+end_src

** Programming languages

#+begin_src emacs-lisp :tangle yes
  (want-drones lua-mode
               rust-mode)
#+END_SRC

*** C/C++

#+begin_src emacs-lisp :tangle yes
  (want-drones clang-format
               company-irony
               company-irony-c-headers
               flycheck-irony
               irony)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (add-hook 'c-mode-common-hook 'irony-mode)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

  (setq irony-server-install-prefix (expand-file-name "build" (borg-worktree "irony")))

  (with-eval-after-load 'flycheck
    (add-hook 'flycheck-mode-hook #'flycheck-irony-setup))

  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-irony))

  (with-eval-after-load 'irony
    (diminish' irony-mode))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (add-hook 'c-mode-common-hook
            (lambda ()
              (local-set-key (kbd "C-c o") 'ff-find-other-file)))
#+end_src

*** Haskell

Intero mode is a ‚Äúcomplete interactive development program for
Haskell‚Äù:

#+begin_src emacs-lisp :tangle yes
  (want-drones haskell-mode
               hayoo
               intero)

  (intero-global-mode)

  (setq intero-blacklist '("~/.dotfiles"))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (general-define-key :keymaps 'haskell-mode-map
                      "<f1> <f1>" 'hayoo-query)
#+end_src

*** Lisps

#+begin_src emacs-lisp :tangle yes
    (add-hook 'lisp-mode-hook
              (lambda ()
                (setq outline-heading-alist
                      (thblt/mk-outline-heading-alist ";;" ?\; " "))))
#+END_SRC

*** Web development

#+begin_src emacs-lisp :tangle yes
  (want-drones emmet-mode
               haml-mode
               less-css-mode
               scss-mode
               skewer-mode
               web-mode)

  (setq scss-compile-at-save nil)
  (add-to-list 'auto-mode-alist '("\\.css\\'" . scss-mode))

  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
#+end_src

** Misc syntaxes

#+begin_src emacs-lisp :tangle yes
  (want-drones json-mode
               toml-mode
               yaml-mode

               cmake-mode)
#+END_SRC

*** Gettext (PO)

#+begin_src emacs-lisp :tangle yes
  (want-drone po-mode)

  (autoload 'po-mode "po-mode"
    "Major mode for translators to edit PO files" t)
  (setq auto-mode-alist (cons '("\\.po\\'\\|\\.po\\." . po-mode)
                              auto-mode-alist))
#+END_SRC

* Tools

This section deals with tools which don't edit anything.

#+begin_src emacs-lisp :tangle yes
  (want-drones debian-bug
               dired+)
#+END_SRC

** TODO Borg and their Queen

*** Borg

Borg is initialized from =init.el=.  As with other Emacs' package
management systems, we still run the risk of keeping unneeded
packages.  What follows is an attempt to address this issue: a utility
function =(=want-drone)= to declare that a package is required (declared
in =init.el=), and a few more functions to keep track of what is
installed using the dependency tree and the set of explicitly required
packages as a base.

#+begin_src emacs-lisp :tangle yes
  (require 'cl-lib)
  (require 'epkg)

  (defun thblt/borg-mk-dep-list ()
    ""
    (let ((drones (borg-drones)))
      (cl-pairlis drones
                  (mapcar
                   (lambda (d)
                     (cl-remove-if-not
                      (lambda (p) (member p drones))
                      (mapcar 'car (epkg-required d))))
                   drones))))

  (defun thblt/borg-clones-strict ()
    "Return a list of strict clones, ie clones that are not assimimated as submodules."
    (let ((drones (borg-drones)))
      (cl-remove-if (lambda (obj) (member obj drones)) (borg-clones))))
  #+END_SRC

*** Borg-Queen

#+begin_src emacs-lisp :tangle yes
  (setq borg-queen-pgp-global-keys '("1B1336171A0B9064"))
#+END_SRC

** Calendars

#+begin_src emacs-lisp :tangle yes
  (want-drone calfw)

  (setq cfw:display-calendar-holidays nil
        ;; Grid characters
        cfw:fchar-vertical-line ?‚îÇ
        cfw:fchar-horizontal-line ?‚îÄ
        cfw:fchar-junction ?‚îº
        cfw:fchar-top-junction ?‚î¨
        cfw:fchar-top-left-corner ?‚ï≠
        cfw:fchar-top-right-corner ?‚ïÆ
        cfw:fchar-left-junction ?‚îú
        cfw:fchar-right-junction ?‚î§)
#+END_SRC

** Ebib

#+begin_src emacs-lisp :tangle yes
  (want-drone ebib)

  (setq ebib-bibtex-dialect 'biblatex)
#+end_src

** ERC

#+begin_src emacs-lisp :tangle yes
  (want-drone erc-hl-nicks)

  (setq erc-server "irc.freenode.net"
        erc-port 7000
        erc-nick "thblt"
        erc-nick-uniquifier  "`"

        erc-server-auto-reconnect t

        erc-lurker-hide-list '("JOIN" "PART" "QUIT")
        erc-lurker-threshold-time 900 ; 15mn

        erc-header-line-format nil)

  (add-hook 'erc-mode-hook (lambda ()
                             (visual-line-mode)
                             (erc-hl-nicks-mode)
                             (erc-fill-disable)))

  (advice-add 'load-theme :after (lambda (&rest _) (when (functionp 'erc-hl-nicks-reset-face-table)
                                                     (erc-hl-nicks-reset-face-table))))
#+END_SRC

** TODO Magit and Git

#+begin_src emacs-lisp :tangle yes
  (want-drones magit
               git-timemachine)

  (general-define-key
   "C-x g s" 'magit-status
   "C-x g r" 'magit-list-repositories
   "C-x g t" 'git-timemachine)
#+end_src

Use Projectile projects as a source of repositories:

#+begin_src emacs-lisp :tangle yes
  (defun thblt/update-magit-repository-directories (&rest _)
    (setq magit-repository-directories (mapcar (lambda (x) `(,x . 0)) projectile-known-projects)))

  (advice-add 'magit-status :before 'thblt/update-magit-repository-directories)
  (advice-add 'magit-list-repositories :before 'thblt/update-magit-repository-directories)
#+end_src

*** magit-list-repositories

=magit-list-repositories= provides a summary view of multiple
repositories.

First, let's configure the view.

#+begin_src emacs-lisp :tangle yes
  (setq magit-repolist-columns
        '(
          ("Name"       25  magit-repolist-column-ident nil)
          ("Branch"     10  magit-repolist-column-branch)
          ("Version" 25  magit-repolist-column-version nil)
          ("Upstream"   15  magit-repolist-column-upstream)
          ("‚ÜìU"         5   magit-repolist-column-unpulled-from-upstream)
          ("‚ÜëU"         5   magit-repolist-column-unpushed-to-upstream)
          ("‚ÜìP"         5   magit-repolist-column-unpulled-from-pushremote)
          ("‚ÜëP"         5   magit-repolist-column-unpushed-to-pushremote)
          (""           6   magit-repolist-column-dirty)
          ("Path"       99  magit-repolist-column-path nil)))
#+end_src

An extra feature: update all remotes.  Probably very dirty.

#+begin_src emacs-lisp :tangle yes
  (require 'cl)
  (require 'magit-repos)

  (defun thblt/magit-repolist-fetch-all ()
    "@TODO Add documentation"
    (interactive)
    (mapc (lambda (d)
            (shell-command
             (format "git -C %s fetch --all &"
                     (shell-quote-argument
                      (expand-file-name (car d))))))
          magit-repository-directories))

  (define-key magit-repolist-mode-map (kbd "G") 'thblt/magit-repolist-fetch-all)
#+end_src

** Mu4e

Configuration for mu4e is split between a published part, below, and a
private part, tangled from =~/.emacs.d/dotemacs-private.org=.  The public part
contains common mu4e settings, the private parts defines accounts and
bookmarks.

mu4e is loaded as a regular Emacs package, complete with its binary, build through usual Borg mechanisms.

#+begin_src emacs-lisp :tangle yes
  (setq mu4e-mu-binary (expand-file-name "mu/mu" (borg-worktree "mu4e")))
#+END_SRC


Each of my accounts is synced (by =mbsync=) to a folder at the root of
the Maildir (eg, =~/.Mail/Academic/=).  We then need a function to
switch contexts based on a regular expression on the current Maildir
path.  For some reason, this doesn't come included with mu4e, so here
it is, and it probably comes [[https://www.reddit.com/r/emacs/comments/47t9ec/share_your_mu4econtext_configs/d0fsih6/][from here]].

#+begin_src emacs-lisp :tangle yes
  (defun mu4e-message-maildir-matches (msg rx)
    (when rx
      (if (listp rx)
          ;; if rx is a list, try each one for a match
          (or (mu4e-message-maildir-matches msg (car rx))
              (mu4e-message-maildir-matches msg (cdr rx)))
        ;; not a list, check rx
        (string-match rx (mu4e-message-field msg :maildir)))))
#+end_src

Then the bulk of the config:

#+begin_src emacs-lisp :tangle yes
  (require 'mu4e-contrib)

  (setq
   ;; Use ivy
   mu4e-completing-read-function 'ivy-completing-read

   ;; General settings
   message-send-mail-function 'smtpmail-send-it
   message-kill-buffer-on-exit t
   mu4e-change-filenames-when-moving t  ; Required for mbsync
   mu4e-get-mail-command "mbsync ovh"
   mu4e-headers-auto-update t
   mu4e-html2text-command 'mu4e-shr2text
   mu4e-maildir "~/.Mail/"
   mu4e-update-interval 60 ;; seconds
   mu4e-sent-messages-behavior 'sent

   ;; Behavior
   mu4e-compose-dont-reply-to-self t

   ;; UI settings
   mu4e-confirm-quit nil
   mu4e-hide-index-messages t
   mu4e-split-view 'vertical
   mu4e-headers-include-related t  ; Include related messages in threads
   mu4e-view-show-images t

   ;; UI symbols
   mu4e-use-fancy-chars t
   mu4e-headers-attach-mark '("" . "")
   mu4e-headers-encrypted-mark '("" . "")
   mu4e-headers-flagged-mark '("+" . "‚öë")
   mu4e-headers-list-mark '("" . "")
   mu4e-headers-new-mark '("" . "")
   mu4e-headers-read-mark '("" . "")
   mu4e-headers-replied-mark '("" . "‚Ü©")
   mu4e-headers-seen-mark '("" . "")
   mu4e-headers-unseen-mark '("" . "")
   mu4e-headers-unread-mark '("" . "‚ú±")
   mu4e-headers-signed-mark '("" . "")
   mu4e-headers-trashed-mark '("T" . "T")

   mu4e-headers-from-or-to-prefix '("" . "‚Üí ")

   mu4e-headers-default-prefix '(" " . " ‚îÄ")
   mu4e-headers-duplicate-prefix '("D" . "D")
   mu4e-headers-empty-parent-prefix '("X" . " X")
   mu4e-headers-first-child-prefix '("|" . "‚ï∞‚îÄ")
   mu4e-headers-has-child-prefix '("+" . "‚ï∞‚î¨")

   mu4e-headers-fields '(
                         (:flags          . 5)
                         (:mailing-list   . 18)
                         (:human-date     . 12)
                         (:from-or-to     . 25)
                         (:thread-subject . nil)
                         )

   mu4e-user-mail-address-list '(
                                 "thblt@thb.lt"
                                 "thibault.polge@malix.univ-paris1.fr"
                                 "thibault.polge@univ-paris1.fr"
                                 "thibault@thb.lt"
                                 "tpolge@gmail.com"
                                 )
   mu4e-context-policy 'pick-first
   mu4e-compose-context-policy 'pick-first)

  (add-hook 'mu4e-view-mode-hook (lambda ()
                                   (setq visual-fill-column-width 80)
                                   (visual-line-mode 1)
                                   (visual-fill-column-mode 1)))

  (general-define-key "<f12>"  'mu4e)
  (general-define-key :keymaps 'mu4e-headers-mode-map
                      "("      'mu4e-headers-prev-unread
                      ")"      'mu4e-headers-next-unread)
  (general-define-key :keymaps 'mu4e-view-mode-map
                      "("      'mu4e-view-headers-prev-unread
                      ")"      'mu4e-view-headers-next-unread
                      "c"      'visual-fill-column-mode)
#+end_src

Compose messages with org-mode tables and lists:

#+begin_src emacs-lisp :tangle yes
  (want-drone orgalist)

  (add-hook 'message-mode-hook 'turn-on-orgtbl)
  (add-hook 'message-mode-hook 'orgalist-mode)
#+end_src

** Password management (password-store)

#+begin_src emacs-lisp :tangle yes
  (want-drones auth-password-store
               pass
               password-store)
  (auth-source-pass-enable)
#+END_SRC

** PDF Tools

#+begin_src emacs-lisp :tangle yes
  (want-drone pdf-tools '(tablist))

  (setq pdf-info-epdfinfo-program (expand-file-name "server/epdfinfo" (borg-worktree "pdf-tools")))

  (pdf-tools-install)

  (with-eval-after-load 'tex
    (unless (assoc "PDF Tools" TeX-view-program-list-builtin)
      (add-to-list 'TeX-view-program-list-builtin
                   '("PDF Tools" TeX-pdf-tools-sync-view)))
    (add-to-list 'TeX-view-program-selection
                 '(output-pdf "PDF Tools")))

  (general-define-key :keymaps 'pdf-view-mode-map
                      "s a" 'pdf-view-auto-slice-minor-mode)
#+end_src

** Regular expression builder

We use the =string= syntax, as advised on [[https://www.masteringemacs.org/article/re-builder-interactive-regexp-builder][this Mastering Emacs' article]].

#+begin_src emacs-lisp :tangle yes
  (setq reb-re-syntax 'string)
#+end_src

** scpaste

Technomancy's =scpaste= is a replacement for pastebin, paste.lisp.org,
and similar services.  It generates a HTML page out of a buffer or
region and moves it over to a server using scp.

#+begin_src emacs-lisp :tangle yes
  (setq scpaste-scp-destination "thblt@k9.thb.lt:/var/www/paste.thb.lt/"
        scpaste-http-destination "https://paste.thb.lt"
        scpaste-user-address "https://thb.lt"

        scpaste-make-name-function 'scpaste-make-name-from-timestamp)
#+END_SRC

A lot of packages add overlays which are useful when editing, noisy
when reading.  We advise scpaste so a few minor modes get disabled
before it runs, and restored afterwards.

#+begin_src emacs-lisp :tangle yes
  (defun thblt/scpaste-without-noise (f &rest args)
    (let ((hig highlight-indent-guides-mode)
          (flyc flycheck-mode)
          (flys flyspell-mode))
      (highlight-indent-guides-mode -1)
      (flycheck-mode -1)
      (flyspell-mode -1)
      (apply f args)
      (when hig
        (highlight-indent-guides-mode 1))
      (when flyc
        (flycheck-mode 1))
      (when flys
        (flyspell-mode 1))))

  (advice-add 'scpaste :around 'thblt/scpaste-without-noise)
  (advice-add 'scpaste-region :around 'thblt/scpaste-without-noise)
#+END_SRC

* Conclusion

** HiDPI support (kindof)

This section is made of overrides to improve support for HiDPI
monitors.  It must be at the end, to avoid being overriden by default
settings.

If we're running on a HiDPI machine, we replace the flycheck fringe
bitmap with a larger version.

#+begin_src emacs-lisp :tangle yes
  (when (string-prefix-p  "maladict" system-name)
    (set-face-attribute 'default nil
                        :height 070)

    (setq fringe-mode-explicit t)
    (set-fringe-mode '(16 . 0))

    (define-fringe-bitmap 'flycheck-fringe-bitmap-double-arrow
      (vector
       #b1000000000
       #b1100000000
       #b1110000000
       #b1111000000
       #b1111100000
       #b1111110000
       #b1111111000
       #b1111111100
       #b1111111110
       #b1111111111
       #b1111111111
       #b1111111110
       #b1111111100
       #b1111111000
       #b1111110000
       #b1111100000
       #b1111000000
       #b1110000000
       #b1100000000
       #b1000000000)
      20 10 'center))
#+END_SRC

** Load private configuration

Some parts of this configuration are private and stored elsewhere.  We
now need to load them.  This file will provide a =dotemacs-private=
feature, which is used elsewhere to defer configuration until some
private bits are available.

#+begin_src emacs-lisp :tangle yes
  (let ((mu4e-private-config (expand-file-name "dotemacs-private.org" user-emacs-directory)))

    (if (file-exists-p mu4e-private-config)
        (org-babel-load-file mu4e-private-config)
      (display-warning :warning "Private configuration missing")))
#+END_SRC

** Server configuration

I don't explicitly run the server, but I start new daemons whenever I need one.  With a swarm of instances, updating config may be a pain.  These two functions respectively reload =init.el= and tell all daemons to do so:

#+begin_src emacs-lisp :tangle yes
  (defun thblt/reload-emacs ()
    "Reload Emacs configuration."
    (interactive)
    (load (expand-file-name "init.el" user-emacs-directory)))

  (defun thblt/reload-all-emacsen ()
    "Execute `thblt/reload-emacs' on all servers."
    (interactive)
    (dolist (instance (directory-files server-socket-dir nil (rx bol (not (any ".")))))
      (unless (equal instance server-name)
        (async-shell-command (format "emacsclient -s %s --eval \"(thblt/reload-emacs)\"" instance)))))
#+END_SRC

Also, some utility function:

#+begin_src emacs-lisp :tangle yes
  (defun thblt/server-start (name)
    "Prompt for NAME, then start the Emacs server under that name."
    (interactive "sDaemon name? ")
    (setq server-name name)
    (server-start))
#+END_SRC

** Report success

We finally set the initial contents of the scratch buffer.  This makes
it easy to notice when something went wrong (this may not be obvious
in daemon mode)

#+begin_src emacs-lisp :tangle yes
  (setq initial-scratch-message ";; ‚ïî‚ïê‚ïó‚îå‚îÄ‚îê‚î¨‚îÄ‚îê‚îå‚îÄ‚îê‚îå‚î¨‚îê‚îå‚îÄ‚îê‚î¨ ‚î¨\n;; ‚ïö‚ïê‚ïó‚îÇ  ‚îú‚î¨‚îò‚îú‚îÄ‚î§ ‚îÇ ‚îÇ  ‚îú‚îÄ‚î§\n;; ‚ïö‚ïê‚ïù‚îî‚îÄ‚îò‚î¥‚îî‚îÄ‚î¥ ‚î¥ ‚î¥ ‚îî‚îÄ‚îò‚î¥ ‚î¥\n\n")

  ;; ‚ïî‚ïê‚ïó‚îå‚îÄ‚îê‚î¨‚îÄ‚îê‚îå‚îÄ‚îê‚îå‚î¨‚îê‚îå‚îÄ‚îê‚î¨ ‚î¨
  ;; ‚ïö‚ïê‚ïó‚îÇ  ‚îú‚î¨‚îò‚îú‚îÄ‚î§ ‚îÇ ‚îÇ  ‚îú‚îÄ‚î§
  ;; ‚ïö‚ïê‚ïù‚îî‚îÄ‚îò‚î¥‚îî‚îÄ‚î¥ ‚î¥ ‚î¥ ‚îî‚îÄ‚îò‚î¥ ‚î¥
#+end_src
